--- a/utils.c
+++ b/utils.c
@@ -1,6 +1,54 @@
+#include <string.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <arpa/inet.h>
+#include <unistd.h>
+
 int uh_getifaddr(const char *ifname, struct in_addr *in)
 {
     struct ifreq ifr;
     int s;
+
+    /*
+     * Skip virtual / tunnel / docker / loopback / unused interfaces
+     * to avoid "Cannot get device settings: No such device"
+     */
+    if (
+         !strncmp(ifname, "lo", 2)        ||   /* loopback */
+         !strncmp(ifname, "ifb", 3)       ||   /* IFB qdisc */
+         !strncmp(ifname, "gre", 3)       ||   /* GRE tunnel */
+         !strncmp(ifname, "ip6tnl", 6)    ||   /* IPv6 tunnel */
+         !strncmp(ifname, "tun", 3)       ||   /* tun */
+         !strncmp(ifname, "tap", 3)       ||   /* tap */
+         !strncmp(ifname, "docker", 6)    ||   /* docker bridge */
+         !strncmp(ifname, "veth", 4)      ||   /* docker veth */
+         !strncmp(ifname, "br-", 3)       ||   /* docker bridge */
+         !strncmp(ifname, "ppp", 3)       ||   /* ppp */
+         !strncmp(ifname, "wg", 2)        ||   /* wireguard */
+         !strncmp(ifname, "sit", 3)       ||   /* sit tunnel */
+         !strncmp(ifname, "ipip", 4)          /* ipip tunnel */
+       ) {
+            return -1;
+    }
+
+    /* get iface flags */
+    memset(&ifr, 0, sizeof(ifr));
+    strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
+
+    if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+        return -1;
+
+    if (ioctl(s, SIOCGIFFLAGS, &ifr) < 0) {
+        close(s);
+        return -1;
+    }
+
+    if (!(ifr.ifr_flags & IFF_UP)) { 
+        close(s); 
+        return -1; 
+    }
+
+    /* get IP address */
+    memset(&ifr, 0, sizeof(ifr));
+    strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
+
+    if (ioctl(s, SIOCGIFADDR, &ifr) < 0) {
+        close(s);
+        return -1;
+    }
+
+    if (in)
+        *in = ((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr;
+
+    close(s);
+    return 0;
 }
