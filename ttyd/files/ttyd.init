#!/bin/sh /etc/rc.common

START=99
STOP=50
USE_PROCD=1

NAME=ttyd
PROG=/usr/bin/$NAME

validate_section_ttyd()
{
	uci_load_validate ttyd ttyd "$1" "$2" \
		'enable:bool:1' \
		'port:port' \
		'interface:string' \
		'credential:string' \
		'uid:uinteger' \
		'gid:uinteger' \
		'signal:uinteger' \
		'url_arg:bool' \
		'readonly:bool' \
		'client_option:list(string)' \
		'terminal_type:string' \
		'check_origin:bool' \
		'max_clients:uinteger' \
		'once:bool' \
		'index:string' \
		'ipv6:bool' \
		'ssl:bool' \
		'ssl_cert:file' \
		'ssl_key:file' \
		'ssl_ca:file' \
		'debug:uinteger' \
		'command:string' \
		'username:string' \
		'password:string'
}

generate_self_signed_cert() {
	local ssl_dir="/etc/ttyd"
	local days="$1"
	local bits="$2"
	local country="$3"
	local state="$4"
	local locality="$5"
	local organization="$6"
	local organizational_unit="$7"
	local commonname="$8"
	
	# ç¡®ä¿ç›®å½•å­˜åœ¨
	mkdir -p "$ssl_dir"
	
	# ç”Ÿæˆè‡ªç­¾åè¯ä¹¦
	openssl req -new -newkey rsa:${bits} -days ${days} -nodes -x509 \
		-keyout "${ssl_dir}/ttyd.key" -out "${ssl_dir}/ttyd.crt" \
		-subj "/C=${country}/ST=${state}/L=${locality}/O=${organization}/OU=${organizational_unit}/CN=${commonname}" 2>/dev/null
	
	if [ $? -eq 0 ] && [ -f "${ssl_dir}/ttyd.key" ] && [ -f "${ssl_dir}/ttyd.crt" ]; then
		echo "âœ… Self-signed certificate generated successfully"
		return 0
	else
		echo "âŒ Failed to generate self-signed certificate"
		return 1
	fi
}

ttyd_instance()
{
	[ "$2" = 0 ] || {
		echo "validation failed"
		return 1
	}

	[ "$enable" = 0 ] && return 1
	[ -z "$command" ] && return 1

	# å¤„ç†åŸºæœ¬è®¤è¯
	if [ -n "$username" ] && [ -n "$password" ]; then
		credential="${username}:${password}"
	fi

	# å¤„ç†SSLè¯ä¹¦
	if [ "$ssl" = "1" ]; then
		# æ£€æŸ¥è¯ä¹¦æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™ç”Ÿæˆè‡ªç­¾åè¯ä¹¦
		if [ ! -f "$ssl_cert" ] || [ ! -f "$ssl_key" ]; then
			echo "ğŸ” SSL enabled but certificate files not found, generating self-signed certificate..."
			
			# è¯»å–SSLé…ç½®å‚æ•°
			config_load ttyd
			config_get ssl_days ssl days "730"
			config_get ssl_bits ssl bits "2048"
			config_get ssl_country ssl country "CN"
			config_get ssl_state ssl state ""
			config_get ssl_locality ssl locality ""
			config_get ssl_organization ssl organization ""
			config_get ssl_organizational_unit ssl organizational_unit ""
			config_get ssl_commonname ssl commonname "$(uci get system.@system[0].hostname 2>/dev/null || echo 'OpenWrt')"
			
			# è®¾ç½®é»˜è®¤è¯ä¹¦è·¯å¾„
			ssl_cert="/etc/ttyd/ttyd.crt"
			ssl_key="/etc/ttyd/ttyd.key"
			
			# ç”Ÿæˆè¯ä¹¦
			generate_self_signed_cert "$ssl_days" "$ssl_bits" "$ssl_country" "$ssl_state" \
				"$ssl_locality" "$ssl_organization" "$ssl_organizational_unit" "$ssl_commonname"
		fi
		
		# éªŒè¯è¯ä¹¦æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä¸”å¯è¯»
		if [ ! -r "$ssl_cert" ] || [ ! -r "$ssl_key" ]; then
			echo "âŒ SSL certificate or key file not readable: $ssl_cert or $ssl_key"
			return 1
		fi
		
		echo "ğŸ” Using SSL certificate: $ssl_cert"
	fi

	[ "${interface::1}" = @ ] && {
		interface=$(
			. /lib/functions/network.sh
			network_get_device device "${interface:1}"
			echo -n "$device"
		)
	}

	[ "$url_arg" = 0 ] && url_arg=""
	[ "$readonly" = 0 ] && readonly=""
	[ "$check_origin" = 0 ] && check_origin=""
	[ "$once" = 0 ] && once=""
	[ "$ipv6" = 0 ] && ipv6=""
	[ "$ssl" = 0 ] && ssl=""

	procd_open_instance
	procd_set_param command "$PROG" \
		${port:+-p $port} \
		${interface:+-i $interface} \
		${credential:+-c $credential} \
		${uid:+-u $uid} \
		${gid:+-g $gid} \
		${signal:+-s $signal} \
		${url_arg:+-a} \
		${readonly:+-R} \
		${terminal_type:+-T $terminal_type} \
		${check_origin:+-O} \
		${max_clients:+-m $max_clients} \
		${once:+-o} \
		${index:+-I $index} \
		${ipv6:+-6} \
		${ssl:+-S} \
		${ssl_cert:+-C $ssl_cert} \
		${ssl_key:+-K $ssl_key} \
		${ssl_ca:+-A $ssl_ca} \
		${debug:+-d $debug}
	config_list_foreach "$1" client_option "procd_append_param command -t"
	procd_append_param command $command
	procd_set_param stdout 1
	procd_set_param stderr 1
	procd_set_param respawn
	procd_set_param pidfile "/var/run/${NAME}.pid"
	procd_close_instance
}

start_service() {
	config_load "$NAME"
	config_foreach validate_section_ttyd ttyd ttyd_instance
}

stop_service() {
	service_stop "$NAME"
}

reload_service() {
	stop_service
	start_service
}

shutdown() {
	# close all open connections
	killall "$NAME"
}

service_triggers() {
	procd_add_reload_trigger "$NAME"
}
